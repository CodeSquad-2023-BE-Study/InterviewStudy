# 4회차 : Network

---

## ✅ Q: 로드밸런싱이 왜 필요하고 무엇인지 설명해 주세요. (depth 1)
A: 한 대의 서버만으로 모든 트래픽을 처리하기에는 부족한 경우가 많습니다. 이에 대한 대응 방법으로는 서버의 하드웨어 성능을 향상시키는 것(Scale-up)과 여러 서버가 작업을 분담하여 처리하는 것(Scale-out)이 있습니다. 이때 서버를 스케일 아웃 한다면 로드밸런싱이 필요합니다.

로드 밸런싱은 여러 서버에 트래픽 부하를 균등하게 분산시키는 분산식 웹 서비스 기술입니다. 로드 밸런서는 클라이언트와 서버 사이에 위치하여, 각 서버에 과부하가 걸리지 않도록 트래픽을 적절히 분산시킵니다. 웹 서비스의 규모가 커짐에 따라 추가적인 웹 서버를 도입하고 로드 밸런서로 관리함으로써, 서버의 부하를 효과적으로 관리할 수 있습니다.

- 깜짝 질문 : 로드밸런서를 이용해서 여러대의 서버를 관리하고 있고, 로그인 정보를 세션에 유지하고 있습니다. 이때 로드밸런서의 어떤 기능을 이용해야 사용자가 로그인이 풀리지 않고 사용할 수 있을까요?
    - **세션 지속성(Session Persistence)**: 이 기능은 사용자가 처음 연결될 때 선택된 서버에 대한 정보를 기억하고, 동일한 사용자의 후속 요청을 동일한 서버로 라우팅합니다. 이렇게 함으로써, 사용자의 세션 상태가 해당 서버에 유지되어 로그인 정보가 유지됩니다.
    - **스티키 세션(Sticky Sessions)**: 스티키 세션은 세션 지속성의 한 형태로, 클라이언트의 세션 ID 또는 특정 쿠키를 기반으로 하여 해당 클라이언트의 모든 요청을 동일한 서버로 보내는 방법입니다.

## ✅ Q: VPC와 서브넷에 무엇이고 구성요소는 무엇인지 예시를 들어 설명해주세요. (depth 2)
1. **VPC (Virtual Private Cloud) → 집** : VPC가 고유한 보안 및 연결 규칙을 가진 격리된 네트워크 공간을 의미하며, 이를 통해 사용자들이 안전하게 데이터를 주고받을 수 있는 '우리만의 공간'을 제공한다는 것을 나타냅니다.
2. **서브넷 (Subnet) → 방** :  VPC가 '집'이라면, 서브넷은 방의 역할을 합니다. 각 서브넷은 특정 목적에 따라 구분되며, 예를 들어 private subnet은 데이터베이스(DB) 서버를 위한 공간으로 사용될 수 있습니다.
3. **인터넷 게이트웨이 → 문** : VPC가 외부 세계와 연결되는 진입점을 나타내며, 사용자들이 VPC 내부와 외부 네트워크 간에 데이터를 주고받을 수 있도록 해줍니다.
4. **라우팅 테이블 → 방에 출입할 수 있는 규칙** : 라우팅 테이블이 네트워크 트래픽이 어떻게 이동해야 하는지를 정의하는 규칙들의 집합이며, 이는 마치 사람들이 건물 내에서 이동하는 경로를 정하는 것과 유사합니다.
5. **보안 그룹 (Security Groups) → 보안 시스템** : 보안 그룹은 VPC 내의 인스턴스에 대한 가상 방화벽 역할을 합니다. 보안 그룹은 들어오고 나가는 트래픽을 제어하여, 특정 IP 주소나 포트로부터의 접근을 허용하거나 거부합니다.
6. **NAT 게이트웨이 (NAT Gateways) → 우체통** : NAT 게이트웨이는 프라이빗 서브넷의 인스턴스가 인터넷과 통신할 수 있게 해주는 역할을 합니다. 인스턴스는 외부와 통신할 수 있지만, 외부에서는 해당 인스턴스로 직접적으로 접근할 수 없습니다.
7. **VPC 피어링 (VPC Peering) → 이웃집간의 비밀 길**: 두 VPC 간에 네트워크 연결을 설정하는 것입니다. VPC 피어링을 통해 서로 다른 VPC에 있는 리소스들이 서로 통신할 수 있습니다.
8. **라우트 53 → 집의 주소판**: AWS의 DNS 서비스로, 사용자의 도메인 이름을 VPC의 리소스와 연결하는데 사용됩니다. 사용자들이 도메인 이름을 통해 쉽게 해당 VPC의 리소스를 찾을 수 있게 해줍니다.
9. **Elastic Load Balancer (ELB) → 여러 출입문** : 트래픽을 여러 서버에 분산시켜주는 역할을 합니다. ELB는 네트워크 트래픽을 여러 인스턴스에 균등하게 분산시켜 부하를 관리하고, 가용성을 높입니다.

10. ## ✅ Q: DNS란 무엇이고 어떤 통신 프로토콜을 사용하는지 알려주세요. (depth 2)
11. DNS(Domain Name System)는 인터넷에서 도메인 이름을 IP 주소로 변환하는 시스템입니다. DNS는 사용자가 웹 브라우저에 URL을 입력할 때, 해당 URL의 도메인 이름(예: [www.example.com](http://www.example.com/))을 해당 서버의 IP 주소로 변환하여 웹 브라우저가 서버에 접속할 수 있도록 합니다. 이러한 변환 과정을 "네임 리졸루션(Name Resolution)"이라고 합니다.

DNS는 주로 다음 두 가지 통신 프로토콜을 사용합니다.

1. **UDP(User Datagram Protocol)**: DNS 쿼리의 대부분은 UDP를 사용합니다. UDP는 연결 없이 데이터를 전송하는 프로토콜로, 빠른 속도를 제공하지만 신뢰성이 낮습니다. 대부분의 DNS 요청은 작은 데이터 패킷으로 구성되어 있기 때문에 UDP를 통해 빠르고 효율적으로 처리할 수 있습니다.
2. **TCP(Transmission Control Protocol)**: DNS는 일부 상황에서 TCP를 사용합니다. 예를 들어, DNS 응답이 크거나(512바이트를 초과하는 경우), DNS 존 전송(zone transfer)과 같은 더 신뢰성이 필요한 상황에서는 TCP를 사용합니다.

3. ## ✅ Q: WebSocket이 무엇인지 설명해주세요. (depth 2)
4. **WebSocket: 개념 및 배경**

- WebSocket은 웹 페이지의 한계를 넘어 실시간 상호작용을 가능하게 하는 웹 통신 표준입니다. 이를 통해 사용자와 서버 간에 지속적이고 실시간 데이터 교환을 할 수 있습니다.
- 기존 HTTP 프로토콜은 주로 클라이언트에서 서버로의 단방향 통신에 적합했습니다. 실시간 웹 기능 구현을 위해 AJAX의 Polling, Streaming 방식을 사용했으나, 이는 브라우저 간 구현 방식의 차이로 인해 개발에 어려움이 있었습니다. 이러한 한계를 극복하기 위해 HTML5 표준의 일환으로 WebSocket이 도입되었습니다.

**WebSocket과 일반 TCP Socket의 차이점**

- WebSocket은 초기 연결 설정 시 일반 HTTP 요청을 통해 핸드셰이킹(handshaking) 과정을 거쳐 연결이 이루어집니다.

**WebSocket의 특징**

- 자유롭고 효율적인 양방향 데이터 교환을 지원합니다.
- 일반 HTTP 요청-응답 관계보다 더 간편하게 데이터를 주고받을 수 있습니다.
- 주로 80포트(HTTP) 또는 443포트(HTTPS)를 통해 웹 서버에 연결합니다.
- URL 형식은 `ws://` 또는 `wss://` (보안 연결)로 시작합니다.
- 다양한 웹 서버 및 클라이언트(브라우저)에서 지원됩니다. 주요 웹 서버 구현체로는 Jetty, GlassFish, Node.js, Netty, Grizzly 등이 있으며, 대부분의 현대 브라우저가 WebSocket을 지원합니다.

**장점**

- 기존 HTTP/HTTPS 포트(80, 443)를 사용하기 때문에 별도의 방화벽 설정 없이 양방향 통신이 가능합니다.
- 기존의 HTTP 기반 인증, CORS(Cross-Origin Resource Sharing) 등의 보안 규칙을 그대로 적용할 수 있습니다.

- ## ✅ Q: TCP의 3 way handshake 과 4 way handshake 에 대해서 설명해주세요. (depth2)

- ### **1. TCP의 3-way Handshake (연결 설정)**

'3-way handshake'는 TCP 연결을 시작할 때 사용되는 과정입니다. 이 과정은 클라이언트와 서버 간에 안정적인 연결을 수립하기 위해 사용됩니다.

1. **SYN**: 클라이언트가 서버로 SYN(Synchronize) 패킷을 보냅니다. 이 패킷은 클라이언트가 서버와 통신을 시작하고자 함을 알리며, 연결을 초기화하는 데 사용되는 시퀀스 번호를 포함합니다.
2. **SYN-ACK**: 서버는 클라이언트에게 SYN-ACK(Synchronize-Acknowledgment) 패킷을 보냅니다. 이는 서버가 클라이언트의 SYN 요청을 받았으며, 자신의 SYN 요청과 ACK(Acknowledgment)를 동시에 보내는 것입니다.
3. **ACK**: 클라이언트는 서버의 SYN-ACK 패킷을 받고, ACK 패킷을 서버에게 보냅니다. 이것으로 클라이언트는 서버의 SYN 요청을 인정하고, 서버도 이 ACK 패킷을 받음으로써 양쪽 모두 연결이 성공적으로 수립되었음을 인지합니다.

이렇게 3단계의 핸드셰이크 과정을 거쳐 TCP 연결이 수립됩니다.

### **2. TCP의 4-way Handshake (연결 해제)**

'4-way handshake'는 TCP 연결을 종료할 때 사용되는 과정입니다. 이 과정은 연결을 안전하게 종료하기 위해 사용됩니다.

1. **FIN**: 클라이언트는 연결을 종료하고자 할 때 서버에게 FIN(Finish) 패킷을 보냅니다. 이는 클라이언트가 더 이상 데이터를 보낼 것이 없음을 의미합니다.
2. **ACK**: 서버는 클라이언트의 FIN 패킷을 받고, ACK 패킷을 클라이언트에게 보내 연결 종료 요청을 받았음을 인지합니다. 그러나 서버는 아직 클라이언트에게 보낼 데이터가 있을 수 있으므로, 모든 데이터 전송을 마칠 때까지 연결을 유지합니다.
3. **FIN**: 서버가 모든 데이터를 클라이언트에게 전송하고 나면, 서버도 FIN 패킷을 클라이언트에게 보내 연결 종료를 준비합니다.
4. **ACK**: 클라이언트는 서버의 FIN 패킷을 받고, 마지막으로 ACK 패킷을 서버에게 보내 연결 종료 과정을 완료합니다. 클라이언트는 이 ACK 패킷을 보낸 후 잠시 대기 상태(TIME_WAIT)에 들어가서, 서버가 ACK 패킷을 제대로 받았는지 확인합니다.

이렇게 4단계의 핸드셰이크 과정을 거쳐 TCP 연결이 안전하게 종료됩니다. 이 과정은 TCP의 신뢰성 있는 연결 지향적 특성을 보장하는 중요한 메커니즘입니다.

---

## ✅ HTTP와HTTPS 차이점에 대해 설명해주세요.
둘다 TCP/IP위에서 동작합니다.

## HTTP

- 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜
- 낮은 신뢰성 누가 요청을 보내와도 응답을 해줍니다. 즉 요청한 클라이언트에 대한 확신이 없습니다. 응답해주는 서버도 확신이 없습니다.

즉 정보에 대한 신뢰성이 떨어집니다.

### HTTPS

- 443포트
- SSL/TLS 인증서를 회득해야함
- 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용하고 있다
- 검색 엔진에서도 HTTP 보다는 HTTPS를 권장하고 검색에서도 가산점을 줍니다.

### 추가적으로 실제 HTTPS 연결 과정이 성립되는 흐름을 살펴보면 다음과 같다.

1. 클라이언트(브라우저)가 서버로 최초 연결 시도를 함
2. 서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨줌
3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함
4. 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송함
5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음
6. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행함

## ✅ 3핸드쉐이크,4헨드쉐이크에 대해 설명해주세요.

### 3핸드쉐이크 순서

1. 클라이언트가 서버에게 SYN 패킷을 보낸다
    
    이때 클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 **SYN_SENT** 상태, **서버는 Wait for Client** 상태이다.
    
2. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보낸다 (sequence : y, ACK : x + 1)
    
    **서버**는 **SYN_RECEIVED** 상태가 된다.
    

포인트는  ACK와 SYN 패킷을 둘다보낸다

1. 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄
    
    이때의 **서버 상태가 ESTABLISHED** 이다.
    

### tcp는 종료할때도 신호를 보낸다( 4핸드쉐이크)

1. 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다. 
    
     이때  **클라이언트는  FIN-WAIT** 상태가 된다.
    
2. B서버는 FIN플래그를 받고, 일단 확인메시지 ACK 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 **서버의 CLOSE_WAIT**상태다.
3. 연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해  클라이언트에게 FIN플래그를 전송한다. 이때 서버의 상태는 **LAST-ACK**이다. (중요 서버가 클라이언트한테 보내는거임)
4. 클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보낸다.

### 참고

tcp는 연결을 위해 tcp 헤더의 코드비트를 사용한다.

1. 지연(delay)된 패킷이 다음 연결에 영향을 주는 것을 막기 위해서입니다. 문제가 생겨 전송이 지연된 패킷이 존재할 때, 직전에 연결 해제한 동일한 두 클라이언트가 동일한 포트를 이용해 재연결을 빠르게 시도할 경우, 지연된 패킷이 이때 도착하게 되어 데이터 무결성을 해칠 수 있습니다. sequence number까지 동일해야 하기 때문에 드문 일이긴 하지만, 가능성이 없는 건 아니므로 이를 방지하기 위해, 정해진 시간 이후 연결을 종료합니다.
2. Server(Passive Close) 측의 연결 종료를 보장해주기 위해서입니다. 만약, Active Close에서 보낸 ACK 패킷이 유실될 경우, Passive Close는 LAST_ACK 상태에서 ACK를 기다리고 있습니다. 즉, Passive Close는 아직 연결 중인 상태라고 착각하고 있는 것입니다.
이 상황에서 TIME_WAIT이 짧거나 해당 상태 없이 연결 해제 후 재연결을 할 경우, 재연결 과정의 3-way handshake에서 SYN 패킷을 Passive Close에게 전송하여도 Passive Close는 LAST_ACK 상태이기 때문에 RST 패킷을 반환하며 연결 Error가 발생하게 됩니다.
따라서, TIME_WAIT을 통해 ACK 패킷이 유실된 경우에도, Passive Close가 FIN 패킷을 재전송해줬을 때 Active Close가 다시 ACK 패킷을 보내줄 수 있도록 연결을 유지시킵니다.
    
    https://tech.kakao.com/2016/04/21/closewait-timewait/


## ✅ HTTP 프로토콜의 특징에 대해 설명해주세요.
- 애플리케이션 레벨의 프로토콜로 **TCP/IP위에서 작동**한다.
- HTTP는 **어떤 종류의 데이터든지 전송**할 수 있도록 설계돼 있다.
- HTTP로 보낼 수 있는 데이터는 **HTML문서, 이미지, 동영상, 오디오, 텍스트 문서** 등 여러종류가 있다.
- 하이퍼텍스트 기반으로(Hypertext) 데이터를 전송하겠다(Transfer) = **링크기반으로 데이터에 접속**하겠다는 의미이다.
- **Connectionless & Stateless 서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다.**
    - 장점: 불특정 다수를 대상으로 하는 서비스에 적합한 방식이다.
    - 단점: 연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수가 없다.
        - 클라이언트의 이전 상태 정보를 알 수 없게 되면, 웹 서비스를 하는데 당장에 문제가 생긴다.
            
            클라이언트가 과거에 로그인을 성공하더라도 로그 정보를 유지할 수가 없다. HTTP는 cookie를 이용해서 이 문제를 해결하고 있다.
            
https://shlee0882.tistory.com/107

## ✅ HTTP 프로토콜 하면 URI도 빼먹을수 없다 URI란?
**HTTP는 전송 프로토콜이고, URI는 자원의 위치를 알려주기 위한 프로토콜**이다.

### **URI :(Uniform Resource Identifier) :통합 자원 식별자**

즉, URI는 인터넷상의 리소스 **“자원 자체”**를 식별하는 고유한 문자열을 말한다.

### **URL :(Uniform Resource Locator) :네트워크상에서 통합 자원(리소스)의 “위치”를 나타내기 위한 규약**

url은 url와 다르게 프로토콜 도한 알아야 접속이 가능합니다. 즉 네트워크사으이 자원을 모두 표기합니다.

**|** URI= 식별자, URL=식별자+위치

ex) [example**.co.kr](http://example.co.kr) 은 URL  https://**[example**.co.kr](http://example.co.kr) 은 URI**

https://www.elancer.co.kr/blog/view?seq=74

## ✅ 쿠키와 세션의 차이점에 대해 말해주세요. (집중 공부)

### 쿠키에 대해 말해주세요

```
쿠키는 **클라이언트(로컬)**에 저장되는 키와 값이 들어있는 작은 데이터 파일이다. 이러한 쿠키는 클라이언트에 저장되어 필요시 정보를 참조하거나 재사용할 수 있다.
```

#### 왜 쓰나요?

http의 **Connectionless(비연결성),Stateless(무상태)때문에 사용합니다.**

#### 구성

- 이름, 값, 유효시간, 도메인 ,경로

### 동작 방식

1.http 요청

2.http응답을 하며 헤더에 set-cookie옵션을 통해 쿠키를 포함해 보낸다.

3.이때 클라이언트는 해당 쿠키를 쿠키 저장소에 저장해 놓는다(로컬에 저장 즉 클라이언트가 가지고있습니다.)

### 세션에 대해 말해주세요

```
세션은 일정 기간 동안 같은 사용자(클라이언트)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이다.
```

- 세션은 쿠키를 기반으로 하지만 쿠키와 다르게 서버 측에서 저장하고 관리합니다.
- 서버는 세션 ID를 이용해 클라이언트를 구분하며,웹 브라우저가 서버에 접속해 브라우저를 종료할 때까지 세션을 유지한다.

### 동작 방식

1.http 요청

2.서버에서 세션 생성

3.http응답을 할때 헤더 set-cookie에 세션 ID를 담은 쿠키를 생성해 보낸다.

3.이때 클라이언트는 해당 쿠키를 쿠키 저장소에 저장해 놓는다(로컬에 저장 즉 클라이언트가 가지고있습니다.)

### 차이점

- 쿠키는 클라이언트에 세션은 서버에 저장 즉 쿠키는 서버의 자원을 사용하지 않는다.
- 세션이 보안에 더우수 쿠키에는 민감한 정보를 넣을 경우 가로채질수있다.
- 세션은 쿠키를 이용할때 쿠키에 세션 ID만 저장하므로 보안성이 좋다.
- 쿠키는 만료시간 동안 파일로 저장되므로 브라우저를 종료해도 정보가 남는다.
- 세션은 브라우저가 종료되면 만료시간에 상관없이 삭제된다. // 이거는 검증필요

---

## ✅ HTTP 주요 메서드에 대해 설명해주세요.
- 주요 HTTP 메서드에는 GET, POST, PUT, DELETE가 있다.
    - **GET**은 특정한 리소스를 가져오도록 요청한다.
    - **POST**는 서버에 데이터를 전송한다.
        - 요청 본문의 유형은 Content-Type 헤더로 나타낸다.
    - **PUT**은 요청 페이로드를 사용해 새로운 리소스를 생성하거나, 대상 리소스를 나타내는 데이터를 대체한다.
    - **PATCH**는 리소스의 부분적인 수정을 할 때에 사용된다.
    - **DELETE**는 지정한 리소스를 삭제한다.
- PUT과 PATCH의 차이는 `멱등성`이다.
    - **PUT**은 멱등성을 가진다. PUT은 한 번을 보내도, 여러 번을 연속으로 보내도 같은 효과를 보인다.
    - **PATCH**는 멱등성을 가지지 않는다. 다른 리소스에게 부수효과(side-effects)를 일으킬 가능성이 있다.

[GET - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/GET)

## ✅ GET과 POST의 차이점에 대해 설명해주세요.

**GET**

- GET은 리소스를 조회하기 위해 사용한다.
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달한다.
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않는다.

**POST**

- POST는 요청 데이터를 처리하기 위해 사용한다.
- **메시지 바디를 통해 서버로 요청 데이터를 전달한다.**
- 서버는 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용한다.

[모든 개발자를 위한 HTTP 웹 기본 지식 - 인프런 | 강의](https://www.inflearn.com/course/http-웹-네트워크)

## ✅ JSON 데이터 포맷을 사용하여 복잡한 데이터 구조를 어떻게 효율적으로 표현하고 관리할 수 있는지 설명해주세요.

- JSON은 경량의 데이터 교환 형식이며, 데이터를 name-value 쌍으로 표현한다. 이 형식의 가장 큰 장점은 간결함과 가독성이다.
    - 복잡한 데이터 구조의 경우, JSON은 중첩된 객체와 배열을 사용하여 다양한 수준의 데이터를 구조화한다. 예를 들어, 한 사용자가 여러 주소를 가지고 있다면, 이러한 주소들을 배열 안에 객체로 표현하여 하나의 JSON 객체에 포함시킬 수 있다.
    - 이는 데이터의 계층적 관계를 명확히 하며, 개발자가 필요한 정보에 쉽게 접근할 수 있게 해준다.
- JSON의 중요한 특성 중 하나는 경량 데이터 포맷이라는 점이다. 이 특성은 특히 웹 API와 같은 네트워크 통신에서 큰 이점을 제공한다.
    - JSON 형식의 데이터는 텍스트 기반으로, 복잡한 데이터 구조를 간결하고 효율적으로 표현할 수 있다. 이러한 경량성은 네트워크 대역폭을 절약하며, 데이터 전송 속도를 향상시킨다.
        - 대역폭: 정해진 시간 동안 전송될 수 있는 데이터의 양(주로 속도를 의미)을 뜻한다.
    - 따라서, JSON 형식의 데이터는 네트워크를 통해 빠르고 효율적으로 전송할 수 있으며, 수신 측에서는 적은 자원을 사용하여 이 데이터를 쉽게 처리할 수 있다.
- 또한, JSON은 언어와 플랫폼에 독립적이기 때문에 다양한 프로그래밍 환경에서 널리 사용된다.
    - 대부분의 프로그래밍 언어는 JSON을 파싱하고 생성하는 데 필요한 라이브러리를 내장하고 있거나, 외부 라이브러리를 통해 지원하고 있다.
- 정리하면 JSON은 복잡한 데이터 구조를 간결하고 효율적으로 표현하며, 네트워크를 통한 데이터 교환에 있어서도 매우 효과적인 포맷이다. 이러한 특성으로 인해, 현대 웹 개발에서 JSON은 데이터 표현과 교환의 표준으로 자리 잡았다.

[JSON, 왜 사용할까?](https://esgibtnureins.tistory.com/58)

## ✅ HTTP와 HTTPS의 차이점에 대해 설명해주세요.
**HTTP**

- **보안**: 암호화 되지 않은 평문 데이터를 전송하기 때문에 보안에 취약하다.
- **포트**: 기본 TCP/IP 포트는 80이다.

**HTTPS**

- **보안**: `SSL`(Secure Sockets Layer) 프로토콜 또는`TLS`(Transport Layer Security)의 보안 기능을 사용해 데이터를 암호화 한다.
    - SSL/TLS 인증서를 통해 웹 사이트의 신원 확인 후 서버와 클라이언트 간 암호화된 연결을 설정을 통해 안정성 보호를 이용할 수 있다.
    - HTTPS 통신은 TCP/IP를 사용하면서, 데이터가 전송되기 전에 SSL/TLS를 통해 암호화한다.
- **포트**: 기본 TCP/IP 포트는 443이다.

## ✅ TCP/UDP에 대해 설명해주세요.

**TCP**(전송 제어 프로토콜, Transmission Control Protocol**)**

- 연결지향 - TCP 3 way handshake (가상 연결)
- 데이터 전달 보증한다.
- 순서를 보장한다.
- 신뢰할 수 있는 프로토콜이다.
- 현재는 대부분 TCP를 사용한다.

**UDP**(사용자 데이터그램 프로토콜, User Datagram Protocol)

- 기능이 거의 없다.
- 연결지향 X - TCP 3 way handshake X
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠르다.
- IP와 거의 같다. +PORT +체크섬 정도만 추가된다.
- 애플리케이션에서 추가 작업이 필요하다.

[모든 개발자를 위한 HTTP 웹 기본 지식 - 인프런 | 강의](https://www.inflearn.com/course/http-웹-네트워크)

---

## ✅ RESTful 한 API가 무엇인가요?
- Rest 설계 규칙은 URI는 정보의 자원만 표현해야 하며, 자원의 상태와 행위는 HTTP Method에 명시하는 것
- Representational State Transfer(REST)는 API 작동 방식에 대한 조건을 부과하는 소프트웨어 아키텍처입니다. REST는 처음에 인터넷과 같은 복잡한 네트워크에서 통신을 관리하기 위한 지침으로 만들어졌습니다. REST 기반 아키텍처를 사용하여 대규모의 고성능 통신을 안정적으로 지원할 수 있습니다. 쉽게 구현하고 수정할 수 있어 모든 API 시스템을 파악하고 여러 플랫폼에서 사용할 수 있습니다.
- **균일한 인터페이스**
    - 요청은 리소스를 식별해야 합니다. 이를 위해 균일한 리소스 식별자를 사용합니다.
    - 클라이언트는 원하는 경우 리소스를 수정하거나 삭제하기에 충분한 정보를 리소스 표현에서 가지고 있습니다. 서버는 리소스를 자세히 설명하는 메타데이터를 전송하여 이 조건을 충족합니다.
    - 클라이언트는 표현을 추가로 처리하는 방법에 대한 정보를 수신합니다. 이를 위해 서버는 클라이언트가 리소스를 적절하게 사용할 수 있는 방법에 대한 메타데이터가 포함된 명확한 메시지를 전송합니다.
    - 클라이언트는 작업을 완료하는 데 필요한 다른 모든 관련 리소스에 대한 정보를 수신합니다. 이를 위해 서버는 클라이언트가 더 많은 리소스를 동적으로 검색할 수 있도록 표현에 하이퍼링크를 넣어 전송합니다.
- 무상태
    - REST 아키텍처에서 무상태는 서버가 이전의 모든 요청과 독립적으로 모든 클라이언트 요청을 완료하는 통신 방법을 나타냅니다. 클라이언트는 임의의 순서로 리소스를 요청할 수 있으며 모든 요청은 무상태이거나 다른 요청과 분리됩니다. 이 REST API 설계 제약 조건은 서버가 매번 요청을 완전히 이해해서 이행할 수 있음을 의미합니다.
- 계층화 시스템
    - 계층화된 시스템 아키텍처에서 클라이언트는 클라이언트와 서버 사이의 다른 승인된 중개자에게 연결할 수 있으며 여전히 서버로부터도 응답을 받습니다. 서버는 요청을 다른 서버로 전달할 수도 있습니다. 클라이언트 요청을 이행하기 위해 함께 작동하는 보안, 애플리케이션 및 비즈니스 로직과 같은 여러 계층으로 여러 서버에서 실행되도록 RESTful 웹 서비스를 설계할 수 있습니다. 이러한 계층은 클라이언트에 보이지 않는 상태로 유지됩니다.
- 캐시 가능성
- 온디맨드 코드
    - REST 아키텍처 스타일에서 서버는 소프트웨어 프로그래밍 코드를 클라이언트에 전송하여 클라이언트 기능을 일시적으로 확장하거나 사용자 지정할 수 있습니다. 예를 들어, 웹 사이트에서 등록 양식을 작성하면 브라우저는 잘못된 전화번호와 같은 실수를 즉시 강조 표시합니다. 서버에서 전송한 코드로 인해 이 작업을 수행할 수 있습니다.

## RESTful API를 사용하면 있는 이점

- 확장성
- 유연성
- 독립성

[RESTful API란 무엇인가요? - RESTful API 설명 - AWS](https://aws.amazon.com/ko/what-is/restful-api/)

## ✅ HTTP와 HTTPS의 차이점은 무엇인가요? HTTPS는 어떻게 동작하나요?
![image](https://github.com/CodeSquad-2023-BE-Study/InterviewStudy/assets/103120173/4e3e9f2f-e313-40c0-a67d-ac00cd6f727e)
[SSL과 TLS 비교 - 통신 프로토콜 간의 차이점 - AWS](https://aws.amazon.com/ko/compare/the-difference-between-ssl-and-tls/)

[TLS 핸드셰이크란? | 세션키 교환 | Cloudflare](https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/)

## ✅ 세션 기반 인증과 토큰 기반 인증의 차이점이 무엇인가요? 해본 경험이 있나요?
- HTTP는 **비상태성**이라는 특성을 갖는다. 서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다. HTTP는 바로 직전에 발생한 통신을 기억하지 못한다. 따라서 HTTP 단독으로는 요청한 클라이언트가 이전에 이미 인증과정을 거쳤는지 알 방법이 없다.
- 이런 HTTP 환경에서 서버는 어떤 방식으로 사용자를 인가할까? 웹 어플리케이션에서는 이 문제를 세션 또는 토큰을 사용하여 문제를 해결한다. **즉, 세션과 토큰은 인증 보다는 인가와 관련된 기술이라고 할 수 있다.**
![image](https://github.com/CodeSquad-2023-BE-Study/InterviewStudy/assets/103120173/0a6095aa-05fe-4457-96b2-beab3e28884e)
- 세션 기반 인증이 인증 정보를 서버에 저장하는 방식이라면, 토큰 기반 인증은 인증 정보를 클라이언트가 직접 들고 있는 방식이다. 이때 인증 정보가 토큰의 형태로 브라우저의 로컬 스토리지(혹은 쿠키)에 저장된다. 토큰의 종류에 따라 다르겠지만, 대표적인 토큰인 JWT의 경우 디지털 서명이 존재해 토큰의 내용이 위변조 되었는지 서버측에서 확인할 수 있다.
![image](https://github.com/CodeSquad-2023-BE-Study/InterviewStudy/assets/103120173/4bd2c6d2-7499-4bb9-b115-4e9680c580dd)
https://hudi.blog/session-based-auth-vs-token-based-auth/

## ✅ OAuth 2.0의 동작 방식에 대해 설명해주세요.
[OAuth와 춤을](https://d2.naver.com/helloworld/24942)
![image](https://github.com/CodeSquad-2023-BE-Study/InterviewStudy/assets/103120173/bfa6dce5-2955-47eb-b254-74ac7e3aea1f)

[PAYCO 로그인 및 PAYCO 바로가입 개발 가이드](https://developers.payco.com/guide)

## ✅ 웹소켓 통신에 대해서 알려주세요.
- HTTP를 이용한 실시간 통신의 문제를 해결하기 위해 HTML5부터 웹소켓이 등장했습니다. 웹소켓은 실시간 양방향 통신을 지원하며 한번 연결이 수립되면 클라이언트와 서버 모두 자유롭게 데이터를 보낼 수 있습니다. 이는 채팅과 같은 연속적인 통신에 대해 계속 유사한 통신을 반복하지 않게 해주어 통신의 효율성도 개선하였습니다.
- HTTP를 이용해서 연결을 수립하며 연결 된 이후에도 연결을 할 때 사용했던 포트인 80과 443포트를 이용합니다. 연결 수립은 핸드쉐이크를 통해 이루어지며 핸드쉐이크시 HTTP를 이용합니다.

[Writing WebSocket servers - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)


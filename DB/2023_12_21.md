# 5회차 : DB

## Chapter5. DB

 - ✅  Q: 데이터 관리 시스템의 구성에 대해서 설명해 주세요. (depth 1)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/76f5f623-5699-487b-9e36-23d6556a29f2/5c464753-f84c-406b-9446-6ee5a9ba4fe6/Untitled.png)
    
    - 질의 처리기 : 사용자의 데이터 처리 요구를 해석하여 처리하는 역할을 담당한다.
        - DDL 컴파일러
            - 데이터 정의어로 작성된 스키마의 정의를 해석한다. 그리고 저장 데이터 관리자의 도움을 받아 새로운 데이터베이스를 구축하고 스키마의 정의를 데이터 사전에 저장한다. 데이터 정의어로 작성된 기존 스키마의 삭제나 수정 요청도 처리하며, 변경된 내용을 데이터 사전에 적용한다.
        - DML 프리 컴파일러
            - 응용 프로그램에 삽입된 데이터 조작어를 추출하여 DML 컴파일러에 전달하며 데이터 조작과 관계없는 나머지 코드들은 해당 언어의 컴파일러에 보내진다.
        - DML 컴파일러
            - 데이터 조작어로 작성된 데이터의 처리(삽입, 삭제, 수정, 검색) 요구를 분석하여 런타임 데이터베이스 처리기가 이해할 수 있도록 해석한다.
        - 런타임 데이터베이스 처리기
            - 저장 데이터 관리자를 통해 데이터베이스에 접근하여 DML 컴파일러로부터 전달받은 데이터 처리 요구를 데이터베이스에서 실제로 실행한다.
        - 트랜잭션 관리자
            - 데이터베이스에 접근하는 과정에서 사용자의 접근 권한이 유효한지를 검사하고 데이터베이스 무결성을 유지하기 위한 제약조건 위반 여부를 확인하며 회복이나 병행 수행과 관련된 작업도 담당한다.
- ✅  Q: 키 속성이 무엇인지 설명하고, 적합한 키 속성이 없을 때는 어떻게 해야 하는지 말해주세요.(depth 2)
    
    키 속성은 개체 인스턴스마다 달라 각 개체 인스턴스를 식별하는 데 사용되는 속성입니다. 적합한 키 속성이 없을 때는 두 개 이상의 속성을 조합하여 키 속성으로 사용할 수 있습니다.
    
    "키 속성(key attribute)"은 데이터베이스 관리 시스템에서 중요한 역할을 하는 개념입니다. 키 속성은 데이터베이스 테이블 내의 각 행을 유일하게 식별하는 데 사용되는 속성(또는 속성의 집합)을 의미합니다. 이러한 키 속성은 데이터의 무결성을 보장하고, 데이터를 효율적으로 검색, 수정, 삭제할 수 있게 해줍니다.
    
    키 속성의 종류에는 여러 가지가 있습니다:
    
    1. **기본 키(Primary Key)**: 각 행을 고유하게 식별할 수 있는 속성. 한 테이블에는 하나의 기본 키만 존재하며, 이 값은 고유해야 하고, NULL 값을 가질 수 없습니다.
    2. **외래 키(Foreign Key)**: 다른 테이블의 기본 키를 참조하는 속성. 관계를 맺고 있는 테이블 간의 데이터 무결성을 유지하는 데 사용됩니다.
    3. **대체 키(Alternate Key)**: 기본 키로 사용될 수 있지만 사용되지 않는 속성.
    4. **슈퍼 키(Super Key)**: 테이블 내의 행을 고유하게 식별할 수 있는 하나 이상의 속성의 집합. 기본 키도 슈퍼 키의 한 형태입니다.
    5. **복합 키(Composite Key)**: 두 개 이상의 속성을 결합하여 행을 고유하게 식별하는 키.
    
    적합한 키 속성이 없을 때의 대처 방법:
    
    1. **인공 키(Artificial Key) 생성**: 때로는 자연스럽게 도출되는 키 속성이 없을 수 있습니다. 이럴 때는 인공적으로 고유 식별자를 생성할 수 있습니다. 예를 들어, 각 행에 고유한 번호를 부여하는 'ID' 필드를 만드는 것입니다.
    2. **복합 키 사용**: 두 개 이상의 속성을 결합하여 유일한 키를 형성할 수 있습니다. 이는 각각의 속성만으로는 고유성을 보장할 수 없을 때 유용합니다.
    3. **데이터 모델 재구성**: 적합한 키 속성을 찾을 수 없는 경우, 데이터 모델 자체가 잘못 설계되었을 수 있습니다. 이때는 데이터 모델을 재검토하고 필요에 따라 재구성하는 것이 좋습니다.
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/76f5f623-5699-487b-9e36-23d6556a29f2/d8ee86f8-7b10-46f6-91ed-44638ebcbdb4/Untitled.png)
        
- ✅  Q: 참조 무결성 제약조건에 대해 설명해 주세요. (depth 1)
    
    참조 무결성 제약조건이란 외래키는 참조할 수 없는 값을 가질 수 없다는 규칙입니다. 외래키는 다른 릴레이션의 기본키를 참조하는 속성이고, 릴레이션 간 관계를 표현하는 역할을 합니다. 외래키가 참조할 수 없는 값을 가진다면 두 릴레이션을 연관시킬 수 없기 때문에 외래키 본래의 의미가 없어지기 때문에 외래키는 참조 가능한 값만 가져야 합니다.
    
- ✅  Q: 카디널리티와 카티션 프로덕트의 차이점이 무엇인지 설명해 주세요. (depth 2)
    
    카디널리티(Cardinality)와 카티션 프로덕트(Cartesian Product)는 데이터베이스와 집합 이론에서 사용되는 두 가지 다른 개념입니다.
    
    ### 카디널리티 (Cardinality)
    
    카디널리티는 데이터베이스 관계에서 두 테이블 간의 관계의 성질을 나타냅니다. 이는 한 테이블의 행이 다른 테이블의 행과 어떻게 연결되는지를 설명합니다. 카디널리티의 주요 유형은 다음과 같습니다:
    
    1. **일대일 (One-to-One)**: 한 테이블의 행이 다른 테이블의 단 하나의 행과만 연결됩니다.
    2. **일대다 (One-to-Many)**: 한 테이블의 행이 다른 테이블의 여러 행과 연결될 수 있습니다.
    3. **다대다 (Many-to-Many)**: 한 테이블의 여러 행이 다른 테이블의 여러 행과 연결될 수 있습니다.
    
    ### 카티션 프로덕트 (Cartesian Product)
    
    카티션 프로덕트는 집합 이론과 관계형 데이터베이스에서 사용되는 개념으로, 두 집합 간의 가능한 모든 조합을 나타냅니다. 데이터베이스에서, 카티션 프로덕트는 두 테이블 간의 모든 가능한 행 조합을 생성합니다. 예를 들어, 첫 번째 테이블에 A, B 두 행이 있고, 두 번째 테이블에 1, 2가 있다면, 카티션 프로덕트는 (A,1), (A,2), (B,1), (B,2)의 네 가지 조합을 생성합니다. 이는 일반적으로 JOIN 연산 없이 두 테이블을 결합할 때 발생합니다.
    
    ### 차이점
    
    - **적용 범위**: 카디널리티는 테이블 간의 관계를 설명하는 데 사용되며, 데이터베이스 설계의 중요한 부분입니다. 반면, 카티션 프로덕트는 두 집합 간의 모든 가능한 조합을 나타내며, 주로 집합 이론과 쿼리 처리에서 나타납니다.
    - **목적**: 카디널리티는 데이터 간의 관계와 그 성질을 이해하는 데 중점을 둡니다. 카티션 프로덕트는 두 집합 간의 가능한 모든 조합을 생성하는 것에 초점을 맞춥니다.
    - **결과**: 카디널리티는 데이터베이스의 무결성과 관계를 유지하는 데 사용되며, 관계의 유형을 나타냅니다. 카티션 프로덕트는 종종 비효율적이고 원치 않는 많은 데이터 조합을 생성할 수 있습니다.
- ✅  Q: 데이터베이스의 정규화에 대해서 설명하고 각 정규형에 대한 설명을 해주세요. (depth2)
    
    ### 기본 정규형과 정규화 과정
    
    - 정규형의 종류
        - 릴레이션의 정규화된 정도는 정규형으로 표현한다. 정규형은 두 형식으로 나뉘는데 제 1,2,3정규형,BCNF는 기본 정규형에 속하고, 제 4,5정규형은 고급 정규형에 속한다.
        - 각 정규형에는 만족시켜야 하는 제약조건이 존재한다.
        - 릴레이션이 특정 정규형의 제약조건을 만족하면 릴레이션이 해당 정규형에 속한다고 표현한다.
        - 정규형의 차수가 높아질수록 요구되는 제약조건이 많아지고 엄격해진다.
        - 높은 차수의 정규형이 이상현상이 발생하지 않는 바람직한 릴레이션이지만, 모든 릴레이션이 5정규형에 속해야 하는 것은 아니므로 릴레이션의 특성을 고려하여 적합한 정규형을 선택해야 한다.
    
    !https://blog.kakaocdn.net/dn/b2Fuxt/btshz1nxwjp/QeHHYUjrzjx9fFOvr2pLeK/img.png
    
    ### 제1 정규형 (1NF)
    
    ```
    릴레이션이 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있으면 제 1정규형에 속한다.
    ```
    
    - 릴레이션이 제1 정규형에 속하려면 릴레이션에 속한 모든 속성이 도는 분해되지 않는 원자 값만 가져야 한다.
    - 하나의 속성에 여러 값이 들어가 있는 다중 값 속성은 제 1 정규형을 만족하지 못한다.
    
    !https://blog.kakaocdn.net/dn/ReDJY/btshyVn5AZ6/nIytuCZxEyClsQps1O2XyK/img.png
    
    - 이벤트 참여 릴레이션에 1정규형을 만족하도록 정규화를 수행하면 하나의 속성에 하나의 값만 들어가게 된다.
    
    !https://blog.kakaocdn.net/dn/YKHJP/btshyzeCSnj/Kvbf97BgydKiqhTUACX0L1/img.png
    
    그 결과 1 정규형에는 속하지만 이상현상이 발생할 가능성이 있다.
    
    따라서 이벤트 참여 릴레이션의 함수 종속 관계를 따져봐야 한다.
    
    [제목 없는 데이터베이스](https://www.notion.so/672a2b6e69fb42bc9a3917feb28cf57e?pvs=21)
    
    - 함수 종속 관계를 보면 3가지 이상현상이 발생할 수 있다.
    - 삽입 이상 : 이벤트에 참여하지 않은 새로운 고객을 등록하려 할 때 개체 무결성 제약조건에 위배되어 삽입할 수 없다.
    - 갱신 이상 : 일부 투플의 값만 변경하면 데이터 일관성을 유지할 수 없다.
    - 삭제 이상 : 이벤트 참여 기록을 삭제하면 고객 정보도 함께 삭제된다.
    
    !https://blog.kakaocdn.net/dn/oOvkz/btshys00luX/K85dxLc4iUjfnqgdpwHpB1/img.png
    
    !https://blog.kakaocdn.net/dn/2NwFN/btshAZbKrUt/9LgjRGO2eSGyFRYpHrkn80/img.png
    
    !https://blog.kakaocdn.net/dn/cg5Oym/btshy5D37Ex/KixUlgilLr0suHWUCk3Ark/img.png
    
    - 이러한 이상현상이 발생하는 것은 이 릴레이션이 부분 함수 종속을 포함하고 있기 때문이다.
    - 따라서 2 정규화를 통해 부분 함수 종속을 제거해야 한다.
    
    ### 제2 정규형 (2NF)
    
    ```
    릴레이션이 제 1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제 2정규형에 속한다.
    ```
    
    - 제2 정규형을 만족하려면 부분 함수 종속을 제거하고 모든 속성이 기본키에 완전 함수 종속되도록 릴레이션을 분해하는 정규화 과정을 거쳐야 한다.
    - 이벤트 참여 릴레이션을 두 개의 릴레이션으로 나누면 등급과 할인율 속성에 대한 데이터 중복이 줄어든다.
    
    !https://blog.kakaocdn.net/dn/cdyhOS/btshzYZooqo/DVdFhDahsCz5JgPJ3EM0G0/img.png
    
    - 정규화 과정에서 분해된 릴레이션들을 자연 조인하여 분해 전에 릴레이션으로 다시 복원할 수 있어야 하며 이를 무손실 분해라고 한다.
    
    !https://blog.kakaocdn.net/dn/bbHNak/btshzkVYflq/bGs81dIe1pYPjJJOXrta01/img.png
    
    - 2 정규형에 속하더라도 함수 종속성을 가지고 있기 때문에 이상현상이 발생할 수 있다.
    - 삽입 이상 : 고객 릴레이션에서 새로운 등급을 생성하고 그 등급에 속하는 고객이 없다면 개체 무결성 제약조건을 위배하여 삽입할 수 없다.
    
    !https://blog.kakaocdn.net/dn/bVLxYx/btshzAqHozy/qFoHuEOCR1YbQuXjEOjaGk/img.png
    
    - 갱신 이상 : 고객 릴레이션에서 할인율 속성을 변경하면 모든 투플에 할인율이 동일하게 변경해야 한다. 만약 한 투플만 변경되면 데이터 불일치가 발생한다.
    
    !https://blog.kakaocdn.net/dn/2wnDw/btshA1gJeBk/bvjlRIZlVfxXUoBGxjZVEk/img.png
    
    - 삭제 이상 : 고객 릴레이션에서 고객 탈퇴로 인해 한 투플이 삭제되면 등급과 할인율에 대한 정보까지 삭제된다.
    
    !https://blog.kakaocdn.net/dn/uj5oQ/btshyAd3Cks/guDUfrXCK8X1AxESyEN3w0/img.png
    
    - 이러한 갱신 이상은 여러 함수 종속 관계를 포함하고 있어 이행적 함수 종속이 생기기 때문이다.
    - 따라서 제3 정규화를 통해 이행적 함수 종속을 제거해야 한다.
    
    ### 제3 정규형 (3NF)
    
    ```
    릴레이션이 제 2정규형에 속하고,
    기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3정규형에 속한다.
    ```
    
    - 릴레이션을 구성하는 3개의 속성 집합 X, Y, Z에 대해 함수 종 속 관계 X — Y와 Y — Z가 존재하면 논리적으로 X -> Z가 성립한다.
    - 이때 속성 집합 Z가 속성 집합 X에 이행적으로 함수 종속되었다고 한다.
    - 일반적으로 3개의 X, Y, Z 속성 집합으로 구성된 릴레이션에 X — Y와 Y — Z라는 함수 종속 관계와 이로 인한 X — Z라는 이행적 함수 종속 관계가 존재한다면, 이 같은 함수 종속 관 계의 의미가 유지되도록 분해해야 한다.
    - 즉, X와 Y 속성 집합의 릴레이션과 Y와 Z 속성 집합 의 릴레이션으로 분해한다.
    
    !https://blog.kakaocdn.net/dn/bc2GHE/btshzYd342d/10wvaiSqVg7dUGqp4CKGT1/img.png
    
    !https://blog.kakaocdn.net/dn/bALNiI/btshBmkEuna/M7fTrW1UKNfn4EA0YPFfKk/img.png
    
    - 릴레이션을 분해하면 하나의 릴레이션에 하나의 관계만 존재하게 되어 이행적 함수 종속으로 인한 이상 현상이 발생하지 않게 된다.
    - 고객 릴레이션은 기본키인 고객아이디가 등급을 직접 결정하므로 제3 정규형에 속한다.
    - 마찬가지로 고객등급 릴레이션도 기본키인 등급이 할인율을 직접 결정하므로 제3정규형 에 속한다.
    
    ### 보이스 / 코드(BCNF) 정규형
    
    ```
    릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 보이스 / 코드 정규형에 속한다.
    ```
    
    - 하나의 릴레이션에 여러 개의 후보키가 존재한다면 제3 정규형을 만족하더라도 이상 현상이 발생할 수 있다.
    - 이러한 이상 현상을 해결하기 위해 더 엄격한 제약조건을 제시한 것이 BCNF이다.
    
    !https://blog.kakaocdn.net/dn/JaIYb/btshyVoDMMP/SojsFbdiEGcDPlUK6sXR81/img.png
    
    - 강좌신청 릴레이션은 모든 속성이 원자 값으로만 구성되어 있으므로 제1정규형에 속한다.
    - 그리고 기본키가 아닌 속성인 담당강사번호가 기본키에 완전 함수 종속되며 이행적 함수 종속을 포함하고 있지 않으므로 제2 정규형과 제3 정규형에도 속한다.
    - 하지만 담당강사번호 속성이 후보키가 아님에도 인터넷강좌 속성을 결정하므로 강좌신청 릴레 이션은 BCNF 정규형에는 속하지 않는다.
    
    !https://blog.kakaocdn.net/dn/nBuxF/btshzzSRXbw/8t87c2rDY4NJGXSgZQZzBK/img.png
    
    - BCNF 정규형에 속하지 않은 릴레이션은 이상현상이 발생할 수 있다.
    - 삽입 이상 : 강사가 강좌를 담당하게 되었지만 강좌를 신청한 고객이 없다면 새 투플을 삽입할 수 없다.
    
    !https://blog.kakaocdn.net/dn/bfHhOb/btshCcoxuwx/jmAlQskRq4vefekIutxuV0/img.png
    
    - 갱신 이상 : 인터넷 강좌가 수정되면 강사 한 명이 인터넷 강좌를 하나만 담당해야 한다는 조건에 모순이 발생한다.
    
    !https://blog.kakaocdn.net/dn/bLV89L/btshAAwWvQB/W8kkAUDUteqf3ZDOksAiJK/img.png
    
    - 삭제 이상 : 고객이 인터넷 강좌를 수강 취소하여 투플을 삭제하면 데이터 손실이 발생한다.
    
    !https://blog.kakaocdn.net/dn/qrLvi/btshAAjpIMg/kdVuLDgKILCNuWfEXHfBEk/img.png
    
    - 따라서 이러한 이상 현상을 해결하기 위해서는 후보키가 아닌 결정자를 기준으로 분해해야 한다.
    
    !https://blog.kakaocdn.net/dn/bfVcCl/btshA0ISDKP/cstrTcuZIki6mhiJXV62Ok/img.png
    
    !https://blog.kakaocdn.net/dn/mzTJa/btshA36HNB9/0LkjmRF7LDx9oy2KZNXKCk/img.png
    
    ### 제4 정규형과 제5 정규형 (4NF, 5NF)
    
    ```
    제 4정규형은 릴레이션이 BCNF을 만족하면서, 함수 종속이 아닌 다치 종속을 제거해야 만족할 수 있다.
    ```
    
    ```
    제 5정규형은 릴레이션이 제 4정규형을 만족하면서 후보키를 통하지 않는 조인 종속을 제거해야 만족할 수 있다.
    ```
    
    - 일반적으로는 제3 정규형이나 보이스/코드 정규형에 속하도록 릴레이션을 분해하여 데이터 중복을 줄이고 이상 현상이 발생하는 문제를 해결한다.
    
    ### 정규화 과정 정리
    
    !https://blog.kakaocdn.net/dn/baObsy/btshzC9ReRl/ZcKLTDhBuYURkFQDp7Tpkk/img.png
    
    ---
    

- ✅ **트랜잭션 과 잠금(Lock) 에 대해 말해주세요**
    
    **잠금(Lock)**: 잠금은 여러 커넥션에서 동시에 동일한 자원(레코드, 테이블)을 요청할 경우 한 시점에는 하나의 커넥션만 해당 자원을 변경할 수 있게 해주는 역할을 한다. `동시성 제어를 위한 기능`이다.
    
    추가 적으로 격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것 인지를 결정하는 레벨을 의미합니다.
    
    **트랜잭션(Transaction):**트랜잭션은 `작업의 완전성을 보장해 주는 것`이다. 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상 **Partial Update (부분 업데이트)**이 발생하지 않게 만들어주는 기능이다.
    
    [트랜잭션과 잠금](https://velog.io/@leekhy02/트랜잭션과-잠금)
    
- ✅ ****암호화에 대해 질문 하겠습니다.****
    
    암호화(Encryption): 평문 -> 암호문
    
    복호화(Decryption): 암호문 -> 평문
    
    평문(plain text): 아직 암호화되지 않은 메세지
    
    ### 해시와 암호화와 차이점은?
    
    둘 다 암호화 기법이지만 Hash는 단방향 암호화 기법이고 Encryption은 양방향 암호화 기법이다.
    
    즉  Hash는 평문을 암호화된 문장(텍스트)으로 만들어주는 기능을 합니다. 단방향 이기때문에 **복호화**가 불가능합니다.
    
    Encryption은 평문을 암호화된 문장(텍스트)로 만들어주는 기능을 하고 양방향 이기때문에 암호화된 문장을 다시 **복호화** 하는 기능도합니다.
    [https://velog.io/@leekhy02/암호화](https://velog.io/@leekhy02/%EC%95%94%ED%98%B8%ED%99%94)
    
- ✅ ****데이터베이스, 데이터 모델링 경험이 있으신가요? 어떤 식으로 스키마를 설계 하시고 경험하셨나요?****
    
    저 같은 경우는 **요구사항 분석 → 개념적 설계 (ERD) → 논리적 설계 (관계형 데이터 모델) → 물리적 설계 (SQL)로 결험 해봤습니다.**
    
    프로젝트 경험을 하며 DB스키마 설계한 경험을 설명하면 될 듯 합니다.
    
    [데이터베이스_데이터 모델링](https://velog.io/@leekhy02/데이터베이스데이터-모델링)
    
- ✅ ****쿼리 성능, 최적화 경험이 있으신가요?****
    
    예를 들어
    
    ```sql
    SELECT * FROM TABLE
     WHERE VarcharDataColumn LIKE '%TEST%'
    ```
    
    위와 같은 쿼리를 프로젝트 에서 사용시
    
    **LIKE사용 시 와일드카드 문자열(%)을 String 앞부분에는 배치하지 않는 것이 좋다. 등**
    
    다양한 쿼리를 최적화한 경험 (혹은 JPA 사용하면서 최적화 하는방법, 경험 등을 말하면 좋을 듯합니다)
    
    ### **Explain**
    
    **Explain을 통해 쿼리 실행 계획을 확인 한 후 실행 계획에 대한 정보를 토대로 최적화도 가능합니다.**
    
    ### 전에 학습한 제 블로그 링크인데  이런 가이드를 토대로 최적화를 시도해 보고 있습니다.
    
    [쿼리 성능,최적화](https://velog.io/@leekhy02/쿼리-성능최적화)
    

- ✅ 데이터베이스란 무엇인가요?
    - 데이터베이스는 일정한 규칙, 혹은 규약을 통해 구조화되어 저장 되는 데이터의 모음입니다.
    - 해당 데이터베이스를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)라고 하며, 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정 조회 등을 수행할 수 있습니다.
    - 또한, 데이터베이스는 실시간 접근과 동시 공유가 가능합니다.
- ✅ 이상 현상의 종류와 특징에 대해 설명해주세요
    - 삽입 이상: 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
    - 갱신 이상: 중복 투플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
    - 삭제 이상: 투플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제
    
    이상 현상이 발생하는 이유는 관련 없는 속성들을 하나의 릴레이션에 모아두고 있기 때문입니다.
    이상 현상이 발생하지 않도록 하려면 관련 있는 속성들로만 릴레이션을 구성해야 하는데, 이를 위해 필요한 것이 **정규화**입니다.
    
- ✅ 트리거(Trigger)에 대해 설명해주세요
    - 트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.
    - 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징입니다.
- ✅ 트랜잭션이 무엇인지 설명해주세요
    - 트랜잭션은 작업의 완전성을 보장해줍니다.
    - 즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.
    - 하나의 트랜잭션은 Commit(작업완료)되거나 Rollback(취소)됩니다.
    
    💡 트랜잭션의 특성(ACID)에 대해 설명해주세요.
    
    1. 원자성(Atomicity) 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
    2. 일관성(Consistency) 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
    3. 독립성(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
    4. 영속성(Durability) 완료된 결과는 영구적으로 반영되어야 한다.
